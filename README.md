# BladeRacer-GameDesignPattern
유니티로 배우는 게임 디자인 패턴을 읽고 정리하는 레포지토리

# Singleton

싱글톤은 클래스에 인스턴스가 하나만 있도록 하면서 이 인스턴스에 대한 전역 접근​이 가능한 디자인 패턴이다.  
장점  
1. 이 인스턴스에 대한 전역 접근이 가능하다.  
2. 하나의 인스턴스만을 가지기 때문에 공유 자원을 관리할 때 유용하다. 동시 접근시 리소스의 일관성을 유지할 수 있다.  

단점  
1. 단위테스트가 어려워진다.
2. SOLID 법칙에 위배된다.

# State

객체(Context)가 내부 상태(State)를 기반으로 움직일 수 있도록 하는 디자인 패턴이다.  
Context : 내부 상태를 변경할 수 있도록 요청하는 인터페이스로 현재 상태(Current State)에 대한 포인터를 보유한다.  
IState : 구체적인 상태를 클래스로 연결할 수 있도록 설정하는 인터페이스

<img width="500" src="https://github.com/user-attachments/assets/6478cec0-6329-4e58-bfec-4889c28de15f">


장점  
1. 상태가 개체와 분리되어 있기 때문에 상태별 행동을 구현, 추가, 수정하기 편하다.

단점  
1. 상태간 관계를 정의하지 않아 가독성이 부족할 수 있다(따로 다이어그램을 만들면 좋을것 같다). 상태간 전환을 정의하기 복잡하다.
2. 상태별 구현해야하기 때문에 클래스의 수가 많아진다.
2. SOLID 법칙에 위배된다.

# Event Bus

전역적으로 이벤트를 관리하며 특정한 전역 이벤트 목록을 이벤트버스가 관리한다.  

1. 이벤트 버스 : 게시자와 구독자의 중개자 역할로, 전역접근이 가능하다.  
2. 게시자 : 이벤트 버스에 선언한 특정 종류의 이벤트를 구독자에게 게시할 수 있다.  
3. 구독자 : 이벤트 버스를 통해 이벤트의 구독자로 자신을 등록한다.  

이벤트 버스는 전역 접근이 가능하며 전역 이벤트를 다루기 때문에 어떤 객체든 게시자와 구독자가 될 수 있다.  

<img width="363" alt="이벤트 버스 패턴" src="https://github.com/user-attachments/assets/7eb35ea3-0377-444c-b2f5-0a276dedb7be">

장점  
1. 직접참조 대신 이벤트 버스를 통하기 때문에 익명성이 보장된다.
2. 비동기적으로 이벤트가 발생했을때 확인이 가능하다.  

단점  
1. 구독자가 누구인지, 게시자가 누구인지에 대한 익명성 때문에 디버깅, 유닛 테스트가 어렵다.  

옵저버 패턴은 특정 범위에 종속되지만, 이벤트 버스는 전역이기 때문에 사용할 부분을 잘 판단해야 할 것 같다.  

# Command

객체 행동을 캡슐화하여 재사용성과 확장성을 높이며 의존성을 낮출수 있다.

1. Invoker : 명령을 실행하고, 명령들을 관리하는 객체
2. Receiver : 명령을 받아서 수행할 객체
3. Command : Receiver에서 캡슐화되어 생성된 객체로 Receiver에게 행동을 직접적으로 지시한다.

커맨드 패턴을 사용했을때의 절차는 다음과 같다.  
Client -> Invoker -> Command -> Receiver  

원래라면 Client가 Receiver에게 바로 접근하지만, 커맨드 패턴을 사용하면 두 객체간 의존성도 떨어지고,
Receiver의 행동을 확장할때 별다른 수정이 필요없이 Command 객체를 생성하는식으로 확장성도 챙길 수 있다. 또한 Invoker가 큐에 Command들을 담고 특정 상황이나 일정한 주기별로 이를 실행할 경우에는 비동기 처리도 가능하며 Command의 관리도 가능하다.  

<img width="575" alt="커맨드 패턴" src="https://github.com/user-attachments/assets/788f2d05-90c7-4e0c-9855-db3763bea862">

사진에서는 Client가 Reciever에게 요청하지만, 실제로는 Invoker에게 요청한다.


장점  
1. 객체간 의존성을 낮출 수 있다.
2. 재사용성과 확장성을 높일수 있다.
3. 비동기 처리가 가능하다.

단점  
1. 복잡성 증가
2. Receiver의 행동별로 클래스를 만들어야하기 때문에 클래스가 굉장히 많아진다.
3. 2번과 비슷하게 간단한 행동도 클래스로 만들어야한다.

