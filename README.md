# BladeRacer-GameDesignPattern
유니티로 배우는 게임 디자인 패턴을 읽고 정리하는 레포지토리

# Singleton

싱글톤은 클래스에 인스턴스가 하나만 있도록 하면서 이 인스턴스에 대한 전역 접근​이 가능한 디자인 패턴이다.  
장점  
1. 이 인스턴스에 대한 전역 접근이 가능하다.  
2. 하나의 인스턴스만을 가지기 때문에 공유 자원을 관리할 때 유용하다. 동시 접근시 리소스의 일관성을 유지할 수 있다.  

단점  
1. 단위테스트가 어려워진다.
2. SOLID 법칙에 위배된다.

# State

객체(Context)가 내부 상태(State)를 기반으로 움직일 수 있도록 하는 디자인 패턴이다.  
Context : 내부 상태를 변경할 수 있도록 요청하는 인터페이스로 현재 상태(Current State)에 대한 포인터를 보유한다.  
IState : 구체적인 상태를 클래스로 연결할 수 있도록 설정하는 인터페이스

<img width="500" src="https://github.com/user-attachments/assets/6478cec0-6329-4e58-bfec-4889c28de15f">


장점  
1. 상태가 개체와 분리되어 있기 때문에 상태별 행동을 구현, 추가, 수정하기 편하다.

단점  
1. 상태간 관계를 정의하지 않아 가독성이 부족할 수 있다(따로 다이어그램을 만들면 좋을것 같다). 상태간 전환을 정의하기 복잡하다.
2. 상태별 구현해야하기 때문에 클래스의 수가 많아진다.
2. SOLID 법칙에 위배된다.

# Event Bus

전역적으로 이벤트를 관리하며 특정한 전역 이벤트 목록을 이벤트버스가 관리한다.  

1. 이벤트 버스 : 게시자와 구독자의 중개자 역할로, 전역접근이 가능하다.  
2. 게시자 : 이벤트 버스에 선언한 특정 종류의 이벤트를 구독자에게 게시할 수 있다.  
3. 구독자 : 이벤트 버스를 통해 이벤트의 구독자로 자신을 등록한다.  

이벤트 버스는 전역 접근이 가능하며 전역 이벤트를 다루기 때문에 어떤 객체든 게시자와 구독자가 될 수 있다.  

<img width="363" alt="이벤트 버스 패턴" src="https://github.com/user-attachments/assets/7eb35ea3-0377-444c-b2f5-0a276dedb7be">

장점  
1. 직접참조 대신 이벤트 버스를 통하기 때문에 익명성이 보장된다.
2. 비동기적으로 이벤트가 발생했을때 확인이 가능하다.  

단점  
1. 구독자가 누구인지, 게시자가 누구인지에 대한 익명성 때문에 디버깅, 유닛 테스트가 어렵다.  

옵저버 패턴은 특정 범위에 종속되지만, 이벤트 버스는 전역이기 때문에 사용할 부분을 잘 판단해야 할 것 같다.  
